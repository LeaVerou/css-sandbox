---
title: TAG Explainer (WIP)
manual_toc: true
eleventyNavigation:
  key: query-explainer
  title: TAG Explainer (WIP)
  parent: container-queries
---

_Based on the
[TAG Explainer Template](https://github.com/w3ctag/w3ctag.github.io/blob/master/explainers.md)_

## Authors

- Miriam Suzanne
- ???

## Participate

CSSWG Issues:
- [Single-Axis Containment](https://github.com/w3c/csswg-drafts/issues/1031)

## Table of Contents

<!-- generated by VSCode Markdown All-In-One extension -->

- [Authors](#authors)
- [Participate](#participate)
- [Table of Contents](#table-of-contents)
- [Introduction](#introduction)
- [Goals](#goals)
- [Non-goals](#non-goals)
- [Single-Axis Containment](#single-axis-containment)
  - [Known Issues](#known-issues)
- [Container Queries (`@container`)](#container-queries-container)
- [Key scenarios](#key-scenarios)
  - [Scenario 1](#scenario-1)
  - [Scenario 2](#scenario-2)
- [Detailed design discussion](#detailed-design-discussion)
  - [[Tricky design choice #1]](#tricky-design-choice-1)
  - [[Tricky design choice 2]](#tricky-design-choice-2)
- [Considered alternatives](#considered-alternatives)
  - [[Alternative 1]](#alternative-1)
  - [[Alternative 2]](#alternative-2)
- [Stakeholder Feedback / Opposition](#stakeholder-feedback--opposition)
- [References & acknowledgements](#references--acknowledgements)

## Introduction

Media-queries allow an author to make style changes
based on the overall viewport dimensions --
making responsive design possible in CSS.
But in many cases,
authors are styling modular components
that might appear in a wide variety of contexts within a page,
and there is currently no way to query the available dimensions
based on that context.
This proposal would allow an author to query
the dimensions of a container element
for conditional styling of descendants.

This solution works by applying size & layout containment
to the queried elements.
Any element with both size & layout containment
can be queried using a new `@continer` rule,
with similar syntax to existing media-queries.
Currently, size containment is all-or-nothing.
In order to make that less restrictive for authors,
we are also proposing `inline-size` & `block-size` values
for the `contain` property.

## Goals

Discussion of Container/Element Queries
go back at least a decade,
and have remained one of the more heavily
requested and discussed CSS features
over that period.

There are two common cases
where media queries become particularly problematic:

- Authors want to describe components
  that can exist in different contexts --
  like a sidebar, or the main content area --
  and respond to the size of each context
  without needing to explicitly plan
  for eery possible combination
  of containers and viewport sizes
- When using flexbox and grid layouts,
  available grid-track size can change in ways
  that are difficult to describe based on viewport sizes --
  such as shrinking & growing in regular intervals
  as new columns are added or removed from the grid.

And several common example use-cases
that rely on context-relative styling:

- "Card" layouts often shift their orientation
  based on available space --
  with an image at the top in narrow context,
  moving to the side when there is available space.
- Calendar layouts often shift from list to grid view
  based on available space --
  with nested "events" that need to respond
  to the available space within a single day.
- When setting type,
  authors want to control font-size, line-length, and line-height
  in consistent relationships --
  based on the available space.

For example use-cases, see:

- [Phil Walton's Responsive Components][demo],
- [Typetura](https://typetura.com/) fluid typography
for examples.

[demo]: https://philipwalton.github.io/responsive-components/#overview

## Non-goals

This is not an exclusive solution
to all "responsive component" issues.
There are several other interesting discussions
that would complement this approach --
and solve different but overlapping use-cases:

- Brian Kardell's [`switch()` proposal][switch]
  would provide a value-level condition statement
  based on parent element context,
  without requiring any containment from authors.
  There are some simpler use-cases
  (like changing a single grid-template),
  where that might be a more compact and flexible option for authors.
- At-rule query blocks require an author to define
  external "breakpoints" for change,
  while flexbox & grid provide more intrinsic
  tools that adapt a layout based on both context & content.
  There might be ways to expand on those existing specifications
  to help make components even more intrinsically responsive.
- With both media- and container-queries,
  authors often want the ability to interpolate a value
  from one breakpoint to the next.
  That is especially useful for describing
  changes in typography --
  with fluid text-sizing, line-heights, and line-lengths
  based on available viewport or container dimensions.

[switch]: https://bkardell.com/blog/AllThemSwitches.html

## Single-Axis Containment

_This is a proposed change to the
[CSS Containment Module](https://drafts.csswg.org/css-contain/),
specifically
[size containment](https://drafts.csswg.org/css-contain/#containment-size)._

In order for container-queries to work in a performant way,
authors will need to apply both `size` and `layout` containment
to any element being queried.
In particular,
container elements will need size containment
_on the axis being queried_.

The majority of web layout
is managed through constraints
on a single (often inline) axis,
with intrinsic sizing on the cross (often block) axis.
That flexibility on the cross-axis is required
to allow for changes in content, font size, etc.
While there are some situations where
sizes are extrinsic (and containable) on both axis,
making 2D containment a pre-requisite for container-queries
would eliminate the vast majority of use-cases.

We're proposing two new single-axis values:

```css
.inline-container {
  contain: inline-size;
}

.block-container {
  contain: block-size;
}
```

Elements with `<axis>-size` containment
should have their intrinsic and final layout
on the specified axis
determined without any contributions from their children.
In most cases,
that should be the same as current `contain: size` behavior,
only applied to a single axis.

### Known Issues

There are two known situations in CSS
where changes on the block-axis
can have an impact on the inline-axis layout:

1. When an ancestor of the contained element has `auto` scrolling,
   extra cross-axis size can cause scrollbars
   to appear on the contained-axis.
   This is only an issue when all three are true:

   - Scrollbars are part of the layout flow (they are not overlaid)
   - Overflow on the cross-axis is set to `auto` on _any ancestor_
   - The contained size is impacted by the size of that ancestor

2. Block-axis percentage padding & margins
   are resolved relative to the inline available size.
   That would cause issues when:

   - Containment is on the block-axis
   - Any ancestor has inline-size determined by contents
     (float+auto, min-content, max-content, etc)
   - Any intermediate ancestor has:
     - box-sizing of border-box
     - height determined by the outer ancestor
     - % padding on the block-axis
       (so inner-height decreases as outer-width increases)
   - The container block-size is impacted
     by the inner-size of that ancestor

   See
   [contain-y comment](https://github.com/w3c/csswg-drafts/issues/1031#issuecomment-379463428))
   and related
   [codepen demo](https://codepen.io/anon/pen/aYQLvV?editors=1100).

   That issue is most likely to occur
   when containing the block-axis,
   but nested writing modes
   can flip the impacted axis
   ([contain-x with writing modes](https://github.com/w3c/csswg-drafts/issues/1031#issuecomment-722980450)).

There are likely more issues
that would be revealed during implementation --
but we expect the number to remain low.

These are not entirely new issues.
The sizing/layout specs all have
module-specific caveats for handling
percentages based on available size.
Our proposal is to begin prototyping this feature,
and attempt to address each issue as they arise --
using similar workarounds.
For example:

- For the sake of determining auto scrollbars on ancestors,
  the container contributes an infinite cross-axis size
  (always trigger the scrollbar).
  This is probably the more common edge-case,
  but in many cases auto-scrollbars imply an element
  has containable size on the cross-axis --
  so authors could avoid this by using 2D size containment in those cases?
- For the sake of resolving percentage-padding on the contained axis,
  always resolve to auto.
  This seems to be the existing first-pass behavior
  in many cases where an element has unknown size.
  Since the percentage issue
  only flows one direction --
  from inline-to-block sizing --
  this may only be an issue for `block-size` containment.

Those are not final solutions,
but examples for how we might be able to solve each case individually.

## Container Queries (`@container`)

[etc.]

## Key scenarios

[If there are a suite of interacting APIs, show how they work together to solve the key scenarios described.]

### Scenario 1

[Description of the end-user scenario]

```js
// Sample code demonstrating how to use these APIs to address that scenario.
```

### Scenario 2

[etc.]

## Detailed design discussion

### [Tricky design choice #1]

[Talk through the tradeoffs in coming to the specific design point you want to make.]

```js
// Illustrated with example code.
```

[This may be an open question,
in which case you should link to any active discussion threads.]

### [Tricky design choice 2]

[etc.]

## Considered alternatives

[This should include as many alternatives as you can,
from high level architectural decisions down to alternative naming choices.]

### [Alternative 1]

[Describe an alternative which was considered,
and why you decided against it.]

### [Alternative 2]

[etc.]

## Stakeholder Feedback / Opposition

[Implementors and other stakeholders may already have publicly stated positions on this work. If you can, list them here with links to evidence as appropriate.]

- [Implementor A] : Positive
- [Stakeholder B] : No signals
- [Implementor C] : Negative

[If appropriate, explain the reasons given by other implementors for their concerns.]

## References & acknowledgements

[Your design will change and be informed by many people; acknowledge them in an ongoing way! It helps build community and, as we only get by through the contributions of many, is only fair.]

[Unless you have a specific reason not to, these should be in alphabetical order.]

Many thanks for valuable feedback and advice from:

- [Person 1]
- [Person 2]
- [etc.]
